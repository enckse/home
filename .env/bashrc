#!/bin/bash
export GOPATH="$HOME/.cache/go"
IS_SCHROOT=0
if [ ! -z "$SCHROOT_CHROOT_NAME" ]; then
    IS_SCHROOT=1
fi

export IS_SCHROOT

if [ -e ~/.bash_private ]; then
    source ~/.bash_private
fi

if [ -e ~/.env/machine/bashrc ]; then
    source ~/.env/machine/bashrc
fi

pltidy() {
    local f
    for f in $(git grep "#\!/usr/bin/perl" | cut -d ":" -f 1 | sort); do
       perltidy $f
       mv $f.tdy $f
    done
}

glint() {
    local f
    goimports -l . | grep -v bindata.go | sed 's/^/[goimports]    /g'
    revive ./... | sed 's/^/[revive]       /g'
    for f in $(find . -type f -name "*.go" -exec dirname {} \; | sort -u); do
        go vet $f | sed 's/^/[govet]        /g'
    done
}


if [ $IS_SCHROOT -eq 1 ]; then
    PS1='[\u@${SCHROOT_CHROOT_NAME} \W]\$ '
    return
fi

drudge user.sshkeys check

if [ ! -d $HOME/workspace ]; then
    mkdir -p $HOME/workspace
fi

if [ ! -d $HOME/.env/machine ]; then
    echo "no machine profile set"
fi

if [ ! -e ~/.vimrc ]; then
    ln -sf /etc/voidedtech/skel/vimrc ~/.vimrc
fi

if [ ! -d ~/.gnupg ]; then
    ln -sf ~/.private/gnupg ~/.gnupg
fi

_cleanup-dirs() {
    local f check
    check=/tmp/.cleanup.$(date +%Y%m%d)
    if [ -e $check ]; then
        return
    fi
    for f in swap undo backup; do
        find $HOME/.vim/$f -type f -mtime +1 -delete
    done
    touch $check
}

if [ -d "$HOME/.gnupg" ]; then
    export GPG_TTY=$(tty)
    gpg-connect-agent updatestartuptty /bye >/dev/null
else
    echo "no .gnupg dir"
fi

_cleanup-dirs

echo -e -n "\033[1;31m"

_git_checks() {
    git -C $1 update-index -q --refresh
    git -C $1 diff-index --name-only HEAD --
    git -C $1 status -sb | grep ahead
    git -C $1 ls-files --other --exclude-standard
}

_staged() {
    local dirs working f cnt
    dirs="$HOME/"
    for f in $(ls ~/.private); do
        working=$HOME/.private/$f/
        if [ -d $working/.git ]; then
            dirs="$dirs $working"
        fi
    done
    for f in $(ls ~/workspace); do
        working=$HOME/workspace/$f
        if [ -d $working/.git ]; then
            dirs="$dirs $working"
        fi
    done
    for f in $dirs; do
        cnt=0
        working=$(_git_checks $f)
        if [ ! -z "$working" ]; then
            cnt=$((cnt+1))
        fi
        if [ $cnt -gt 0 ]; then
            echo "$f [$cnt]"
        fi
    done
}

staged=$(_staged | sed 's#/home/enck/#~/#g;s#^#  #g')
if [ ! -z "$staged" ]; then
    echo "git:"
    echo "$staged"
    echo
fi
if [ -d ~/.mutt/maildir ]; then
    staged=$(find ~/.mutt/maildir/ -type f | grep new | xargs -0 dirname | grep -v "Trash/new" | sed 's#/home/enck/.mutt/maildir/fastmail/##g;s#/new##g' | sort | uniq -c | sed 's/^\s*/  /g')
    if [ ! -z "$staged" ]; then
        echo "mail:"
        echo "$staged"
        echo
    fi
fi
echo -e -n "\033[0m"
