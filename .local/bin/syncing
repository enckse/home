#!/usr/bin/python3
"""Resource syncing."""
import common
import subprocess
import os
import datetime
import sys
import time


_DAEMON = "daemon"
_COMMON_STORE = "/mnt/Storage/Active/"
_INBOX_STORE = os.path.join(_COMMON_STORE, "Inbox") + "/"
_PROFILE_PATH = os.path.join(_COMMON_STORE, "Drop", "Profiles") + "/"
_FIND = "find " + _PROFILE_PATH + " -type f -mtime +7 -exec rm {} \\;"
_ETC = os.path.join("/opt", "etcbackup")


def _test_ssh(env):
    """Check ssh connection."""
    r = subprocess.call(["ssh",
                         "-o", "BatchMode=yes",
                         "-o", "ConnectTimeout=5",
                         env.BASE_SERVER,
                         "echo",
                         "online"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL)
    return r == 0


def _call(cmd, stdout):
    """Call with stdout/err to output given."""
    subprocess.call(cmd, stdout=stdout, stderr=stdout)
    if stdout == subprocess.DEVNULL:
        return
    stdout.flush()


def _diff(prev, current):
    """Diff runner."""
    d = subprocess.call(["diff", "-u", prev, current],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL)
    return d == 0


def _scp(env, name, stdout):
    _call(["scp", name, "{}:{}".format(env.BASE_SERVER, _PROFILE_PATH)],
          stdout)


def _backup(env, stdout):
    """Run file backups."""
    backup_file = os.path.join(env.USER_TMP,
                               "backup.{}".format(env.HOUR))
    if os.path.exists(backup_file):
        return
    print("running backup {}".format(backup_file), file=stdout)
    archive = os.path.join(env.USER_TMP,
                           "profile.{}.tar.gz".format(env.AM_PM))
    if not os.path.exists(archive):
        print("creating archive {}".format(archive), file=stdout)
        files = [os.path.join(env.HOME, ".mozilla") + "/",
                 os.path.join(env.HOME, ".bash_history")]
        stdout.flush()
        _call(["tar", "zcf", archive] + files, stdout)
        print("archive created", file=stdout)
        print("publish profile", file=stdout)
        stdout.flush()
        _scp(env, archive, stdout)
        etc = sorted(os.listdir(_ETC))
        if len(etc) > 0:
            etc_file = etc[-1]
            print("backing up etc: {}".format(etc_file), file=stdout)
            _call(["rsync",
                   "-avc",
                   os.path.join(_ETC, etc_file),
                   "{}:{}".format(env.BASE_SERVER, _PROFILE_PATH)],
                  stdout)
        else:
            print("no etc backup", file=stdout)
        _call(["ssh", env.BASE_SERVER, _FIND], stdout)
    for f in os.listdir(env.PERSONAL_LOC):
        if "@" not in f:
            continue
        fpath = os.path.join(env.PERSONAL_LOC, f)
        do = True
        cur = None
        prev = None
        if "localhost" not in f:
            cur = os.path.join(env.USER_TMP, "rsync.mail.{}".format(f))
            prev = cur + ".prev"
            files = []
            for root, _, objects in os.walk(fpath):
                for o in objects:
                    files.append(os.path.join(root, o))
            with open(cur, 'w') as c:
                for o in sorted(files):
                    c.write(o + "\n")
            if os.path.exists(prev):
                if _diff(cur, prev):
                    do = False
                    print("{} no change".format(f), file=stdout)
        if do:
            print("syncing {}".format(fpath), file=stdout)
            stdout.flush()
            _call(["rsync",
                   "-avcr",
                   "--delete-after",
                   fpath + "/",
                   "{}:{}/{}/".format(env.BASE_SERVER, _INBOX_STORE, f)],
                  stdout)
        if cur is not None and prev is not None:
            os.rename(cur, prev)
    open(backup_file, 'w').close()


def _git(env, stdout):
    """Git syncing."""
    dirs = []
    dirs.append(env.PRIV_PATH)
    dirs.append(env.HOME_STORE)
    dirs.append(os.path.join(env.PERM_PASS, "personal"))
    pushes = []
    for d in dirs:
        bname = d.replace(env.HOME, "").replace("/",
                                                " ").strip().replace(" ", "_")
        git_cur = os.path.join(env.USER_TMP, "git.sync." + bname)
        git_prev = git_cur + ".prev"
        with open(git_cur, 'w') as c:
            subprocess.call(["git",
                             "-C",
                             d,
                             "log",
                             "--pretty=format:%h",
                             "-n",
                             "1"],
                            stdout=c)
        push = True
        if os.path.exists(git_prev):
            if _diff(git_prev, git_cur):
                push = False
        if push:
            print("pushing {}".format(d), file=stdout)
            stdout.flush()
            _call(["git", "-C", d, "push"], stdout)
        os.rename(git_cur, git_prev)
        if d != env.HOME_STORE:
            if push:
                print("checking zip status for {}".format(d), file=stdout)
                _zip(env, d, bname, subprocess.DEVNULL)


def _notes(env, stdout):
    for d in ["important"]:
        dirname = os.path.join(env.HOME_STORE, d)
        print("reading notes for {}".format(d), file=stdout)
        if not os.path.exists(dirname):
            continue
        for f in os.listdir(dirname):
            hash_file = os.path.join(env.USER_TMP, "notes.{}.hash".format(f))
            n = os.path.join(dirname, f)
            mod = str(os.path.getmtime(n))
            changed = True
            if os.path.exists(hash_file):
                with open(hash_file, 'r') as h:
                    last = h.read().strip()
                    changed = last != mod
            with open(hash_file, 'w') as h:
                h.write(mod)
            if changed:
                _add_mail(n,
                          "notes: {}".format(f),
                          env,
                          stdout,
                          flags=["--plaintext"])


def _add_mail(fname, subj, env, stdout, flags=[]):
    _call(["python3",
           os.path.join(env.HOME_BIN, "mail.py"),
           "--input",
           fname,
           "--subject",
           subj,
           "--address",
           env.ZIP_MAIL,
           "--maildir",
           os.path.join(env.MAIL_DIR,
                        "fastmail",
                        "Filtered",
                        "Automated") + "/"] + flags,
          stdout)


def _zip(env, directory, basename, stdout):
    """Zip a directory change."""
    dt = datetime.datetime.now().strftime("%Y%m%d.%s")
    mail = "zip.{}.{}".format(basename, dt)
    fname = os.path.join(env.USER_TMP, mail)
    zname = fname + ".7z"
    files = []
    for r, _, file_names in os.walk(directory):
        for f in file_names:
            full_path = os.path.join(r, f)
            if "/.git" in full_path:
                continue
            files.append(full_path)
    _call(["7z", "a", "-spf", "-p{}".format(env.ZIP_PASS), zname] + files,
          stdout)
    bname = basename.split("_")[-1]
    subj = "zips: {}".format(bname)
    _call(["mpack", "-s", subj, "-o", fname, zname], stdout)
    _add_mail(fname, subj, env, stdout)
    os.remove(fname)
    os.remove(zname)


def _sync(env, stdout, dt):
    """Run all syncs."""
    print("SYNC? ({})".format(dt), file=stdout)
    if not _test_ssh(env):
        return False
    print("RUNNING: {}".format(dt), file=stdout)
    stdout.flush()
    _backup(env, stdout)
    _git(env, stdout)
    _notes(env, stdout)
    open(env.LAST_SYNC, 'w').close()
    print("COMPLETE", file=stdout)
    return True


def _email(env):
    """Run email."""
    subprocess.Popen([os.path.join(env.HOME_BIN, "email"), "queue"],
                     stdout=subprocess.DEVNULL,
                     stderr=subprocess.DEVNULL)


def _daemon(env):
    """Run in daemon mode."""
    last = datetime.datetime.now()
    last_minute = -1
    in_error = False
    mutt = False
    _setup_sync(env, last)
    while True:
        sync = in_error
        success = False
        dt = datetime.datetime.now()
        if last_minute == -1:
            last_minute = dt.minute
        if last_minute == 59 and dt.minute == 0:
            sync = True
        if not sync:
            delta = dt - last
            ts = delta.total_seconds()
            ts = ts / 60
            if ts > 20:
                sync = True
        if sync:
            out, err = common.get_output_or_error(["wsw", "--mode", "current"])
            if not err:
                network = out.decode("utf-8").strip()
                found = False
                for n in env.NET_SYNC:
                    if n in network:
                        found = True
                        break
                if not found:
                    sync = False
        if sync:
            success = _setup_sync(env, dt)
            if not success:
                in_error = True
        last_minute = dt.minute
        if success:
            last = dt
            in_error = False
        time.sleep(15)
        m = subprocess.call(["pidof", "mutt"],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL)
        if m == 0:
            if not mutt:
                _email(env)
                mutt = True
        else:
            if mutt:
                _email(env)
                mutt = False


def _setup_sync(env, dt):
    _email(env)
    env.AM_PM = dt.strftime("%Y-%m-%d-%p")
    env.HOUR = dt.strftime("%Y-%m-%d-%H")
    log_file = os.path.join(env.USER_TMP, "sync.{}".format(env.AM_PM))
    with open(log_file, 'a') as f:
        return _sync(env, f, dt)


def _startup(env):
    fname = os.path.realpath(__file__)
    while not os.path.exists(env.SSH_AUTH_TMP):
        time.sleep(1)
    e = os.environ
    with open(env.SSH_AUTH_TMP, 'r') as f:
        e["SSH_AUTH_SOCK"] = f.read().strip()
    subprocess.call([fname, _DAEMON], env=e)


def main():
    """Program entry."""
    env = common.read_env()
    if len(sys.argv) == 1:
        _startup(env)
        return
    if sys.argv[1] == "run":
        dt = datetime.datetime.now()
        if not _setup_sync(env, dt):
            print("failed")
    if sys.argv[1] != _DAEMON:
        return
    _daemon(env)


if __name__ == "__main__":
    main()
