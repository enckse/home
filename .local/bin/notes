#!/usr/bin/python3
import argparse
import os
import subprocess
import sys

_LS_CMD = "ls"
_EDIT_CMD = "edit"
_SHOW_CMD = "show"
_RM_CMD = "rm"
_CMDS = [_LS_CMD, _EDIT_CMD, _SHOW_CMD, _RM_CMD]
_CMDS_EXIST = [_RM_CMD, _SHOW_CMD]
_CMD_EMPTY = [_LS_CMD]
_MD_FILE = ".md"


class Ctx(object):
    def __init__(self):
        self.editor = None
        self.dir = None
        self.browser = None


def _value_or_environ(value, env_key):
    if not value:
        if env_key in os.environ:
            return os.environ[env_key]
    return value


class Obj(object):
    def __init__(self):
        self.exists = False
        self.path = None
        self.input = None
        self.isdir = None


def _get_path(ctx, inputs, must_exist, allow_empty):
    if len(inputs) == 0:
        if not allow_empty or must_exist:
            print("no inputs given")
            return None
        else:
            return []
    results = []
    for i in inputs:
        obj = Obj()
        obj.input = i
        obj.path = os.path.join(ctx.dir, i)
        obj.exists = os.path.exists(obj.path)
        if not obj.exists and must_exist:
            print("{} does not exist".format(i))
            return None
        if obj.exists:
            obj.isdir = os.path.isdir(obj.path)
        results.append(obj)
    return results


def _error(msg):
    print("ERROR: {}".format(msg), file=sys.stderr)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("command")
    parser.add_argument("--directory")
    parser.add_argument("--editor")
    parser.add_argument("--browser")
    args, unknown = parser.parse_known_args()
    if args.command not in _CMDS:
        print("unknown command: {}".format(args.command))
        return
    ctx = Ctx()
    ctx.dir = _value_or_environ(args.directory, "NOTES_DIR")
    ctx.editor = _value_or_environ(args.editor, "EDITOR") or "vi"
    ctx.browser = _value_or_environ(args.browser, "BROWSER") or "firefox"
    if not ctx.dir:
        print("directory not set")
        return
    if not os.path.exists(ctx.dir):
        print("initializing notes directory: {}".format(ctx.dir))
        os.makedirs(ctx.dir)
    f = _get_path(ctx, unknown,
                  args.command in _CMDS_EXIST,
                  args.command in _CMD_EMPTY)
    if f is None:
        return
    if args.command == _LS_CMD:
        ls = []
        prints = []
        if len(f) == 0:
            obj = Obj()
            obj.exists = True
            obj.path = ctx.dir
            obj.isdir = True
            obj.input = ""
            ls.append(obj)
        else:
            ls = [x for x in f]
        for l in ls:
            if l.exists:
                if l.isdir:
                    for o in os.listdir(l.path):
                        u = os.path.join(l.input, o)
                        prints.append((u,
                                       os.path.isdir(os.path.join(l.path, u))))
                else:
                    prints.append((l.input, False))
            else:
                _error("{} does not exist".format(l.input))
        if len(prints) > 0:
            m = max([len(x[0]) for x in prints])
            for obj in sorted(prints):
                color = "92"
                name = obj[0]
                if obj[1]:
                    color = "94"
                    ind = "dr-"
                else:
                    ind = "-"
                    if name.endswith(_MD_FILE):
                        color = "95"
                        ind += "rw"
                    else:
                        ind += "r-"
                print("{} \033[{}m{}\033[0m".format(ind, color, name))
        return
    if args.command == _EDIT_CMD:
        for obj in f:
            if obj.isdir:
                _error("{} is a directory".format(obj.input))
                continue
            use_path = obj.path
            if not use_path.endswith(_MD_FILE):
                if os.path.exists(use_path):
                    _error("{} is not an editable file".format(obj.input))
                    return
                use_path = "{}{}".format(obj.path, _MD_FILE)
            d = os.path.dirname(use_path)
            if not os.path.exists(d):
                os.makedirs(d)
            subprocess.call([ctx.editor, use_path])
        return
    if args.command == _SHOW_CMD:
        for obj in f:
            if obj.isdir:
                continue
            if not obj.path.endswith(_MD_FILE):
                subprocess.call([ctx.browser, obj.path])
                continue
            with open(obj.path, 'r') as fobj:
                for l in fobj.readlines():
                    print(l.rstrip())
    if args.command == _RM_CMD:
        for obj in f:
            if obj.isdir:
                _error("{} cannot remove directories, remove all files".format(obj.input))
                continue
            os.remove(obj.path)
            dname = os.path.dirname(obj.path)
            empty = True
            for o in os.listdir(dname):
                empty = False
                break
            if empty:
                os.rmdir(dname)
            continue


if __name__ == "__main__":
    main()
