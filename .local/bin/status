#!/usr/bin/python3
"""Perform status operations."""
import argparse
import sys
import common
import datetime
import time
import git
import subprocess
import os


_DELIMITER = "|"
_NOTIFICATIONS = 10
_NOTIFY_LEN = str((_NOTIFICATIONS + 5) * 1000)


def _notify(message):
    subprocess.call(["notify-send", "-t", _NOTIFY_LEN, message])


def _notifications(env):
    """Notification outputs."""
    if os.path.exists(env.HIDE):
        return
    git_tmp = env.GIT_STATUS + ".tmp"
    with open(git_tmp, 'w') as f:
        g = git.status(env, f)
    os.rename(git_tmp, env.GIT_STATUS)
    if g > 0:
        _notify("{} ^AHEAD^".format(g))
    out, err = common.get_output_or_error(["email", "count"])
    if err is None:
        emails = out.decode("utf-8").strip()
        if emails:
            _notify(emails)


def _run_command(cmd, append):
    out, err = common.get_output_or_error(cmd)
    if err is None:
        o = out.decode("utf-8").strip()
        if o:
            append.append(o)


def _daemon(env):
    """Daemon runner."""
    state = _NOTIFICATIONS
    while True:
        t = datetime.datetime.now()
        time_format = t.strftime("%Y-%m-%d{}%H:%M".format(_DELIMITER))
        outputs = [time_format]
        out, err = common.get_output_or_error(["xrandr", "--current", "--verbose"])
        bright = "?"
        if err is None:
            lines = [float(x.strip().split(":")[1].strip()) \
                     for x in out.decode("utf-8").split("\n") \
                     if "Brightness" in x]
            len_l = len(lines)
            if len_l > 0:
                bright = str(int(sum(lines) / len_l * 100))
        outputs.append("disp:{}".format(bright))
        _run_command(["locking", "status"], outputs)
        volume = []
        _run_command(["volume", "ismute"], volume)
        _run_command(["volume", "volume"], volume)
        muted = False
        vol = "?"
        if len(volume) == 2:
            muted = volume[0] == "true"
            if muted:
                vol = "0"
            else:
                vol = volume[1]
        outputs.append("vol:{}".format(vol))
        charge = "?"
        with open("/sys/class/power_supply/AC/online", 'r') as f:
            if f.read().strip() == "0":
                charge = "-"
            else:
                charge = "+"
        total_bat = 0
        batteries = []
        for b in range(0, 2):
            bat = "/sys/class/power_supply/BAT{}/capacity".format(b)
            with open(bat, 'r') as f:
                per = f.read().strip()
                total_bat += float(per)
                batteries.append(per)
        if total_bat < 20:
            _notify("WARNING: BATTERY")
        b = ",".join(batteries)
        b = "bat:{}({})".format(charge, b)
        outputs.append(b)        
        if subprocess.call(["wsw", "--mode", "online"]) == 0:
            outputs.append("UP")
        else:
            outputs.append("DOWN")
        _run_command(["wsw", "--mode", "addr"], outputs)
        subprocess.call(["xsetroot", "-name", _DELIMITER.join(outputs)])
        if state >= _NOTIFICATIONS:
            _notifications(env)
            state = -1
        state += 1
        time.sleep(1)


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("command")
    args = parser.parse_args()
    env = common.read_env()
    env.HIDE = os.path.join(env.USER_TMP, "hidden.status")
    env.GIT_STATUS = os.path.join(env.USER_TMP, "git.status")
    if args.command == "git":
        common.red_text()
        subprocess.call(["cat", env.GIT_STATUS])
        common.normal_text()
    elif args.command == "daemon":
        _daemon(env)
    elif args.command == "toggle":
        if os.path.exists(env.HIDE):
            os.remove(env.HIDE)
        else:
            open(env.HIDE, 'w').close()
    else:
        print("unknown command")


if __name__ == "__main__":
    main()
