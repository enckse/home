#!/usr/bin/python3
import os
import argparse
import subprocess
import json
import shutil


def _message(cat, msg):
    print("=> {}: {}".format(cat, msg))


def _warn(message):
    _message("WARN", message)


def _error(message):
    _message("ERROR", message)


_MISSING_PACKAGE = False
try:
    import markdown
except ImportError:
    _error("python-markdown unavailable")
    _MISSING_PACKAGE = True

try:
    import pygments
except ImportError:
    _error("pygments unavailable")
    _MISSING_PACKAGE = True


_STATE = ".mdstate"
_HTMLTOPDF = "wkhtmltopdf"
_PDFUNITE = "pdfunite"
_ROOT = "root"
_CMDS = [_HTMLTOPDF, _PDFUNITE]

_CSS = """
body {
    padding-left: 0.5in;
    padding-right: 0.5in;
    padding-top: 0.5in;
    padding-bottom: 0.5in;
    font-size: 32px;
    line-height: 1.5;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
h1 {
    background-color: #c2d6d6;
    text-align: center;
    font-size: 48px;
}
li:nth-child(odd){
    background: #e6f2ff;
}
li {
    background: #cce6ff;
    list-style-type: square;
    margin: 3px 0;
}
.slide {
    font-size: 18px;
}

table {
  width: 100%;
}

th, td {
  text-align: left;
  padding: 4px;
}

tr:nth-child(even) {
    background-color: #f2f2f2
}

tr {
    background-color: #e6e6e6;
}

th {
  background-color: #666699;
  color: #ffffff;
}
"""


def _list_files(directory, ignores=[]):
    for f in os.listdir(directory):
        if len(ignores) > 0:
            rel = os.path.relpath(f)
            if rel in ignores:
                continue
        path = os.path.join(directory, f)
        if os.path.isfile(path):
            if f.endswith(".md"):
                yield path
        elif os.path.isdir(f):
            subdir = os.path.join(directory, f)
            for sub in _list_files(subdir):
                yield sub


def _write_html(w, css, unique_id, dir_id, obj_id, md, slide, of):
    w.write("<!doctype html><html lang='en'><style>\n")
    w.write(css)
    w.write("</style></head><body>\n")
    slide_progress = "&nbsp;"
    if slide > 1:
        slide_progress = "{} of {}".format(slide, of)
    w.write("<div class='slide'>{}</div>".format(slide_progress))
    w.write("<div class='{} {} slide-{}'>\n".format(unique_id,
                                                    dir_id,
                                                    obj_id))
    w.flush()
    with open(md, 'r') as md_text:
        w.write(markdown.markdown(md_text.read(),
                extensions=["markdown.extensions.tables"]))
    w.write("</div></body></html>")


def _path_cleanup(p):
    r = p
    for obj in [("/", "-"), (".-", "{}-".format(_ROOT)), (".", "")]:
        r = r.replace(obj[0], obj[1])
    return r


def _pygments(args, inputs, css):
    from pygments import highlight
    from pygments.lexers import get_lexer_by_name, guess_lexer
    from pygments.formatters import HtmlFormatter
    idx = 0
    files = []
    formatter = HtmlFormatter()
    did = False
    formatter_css = formatter.get_style_defs()
    for f in sorted(inputs):
        guessed = False
        with open(f, 'r') as in_file:
            output_file = os.path.join(args.output, "{}.md".format(idx))
            print("preprocessing {} to {}".format(f, output_file))
            in_section = None
            lines = []
            lexer_name = None
            for line in [x.rstrip() for x in in_file.readlines()]:
                if line.startswith("```"):
                    if in_section is not None:
                        code = "\n".join(in_section)
                        if lexer_name is None:
                            use_lex = guess_lexer(code)
                            guessed = True
                        else:
                            use_lex = get_lexer_by_name(lex)
                        lines.append(highlight(code, use_lex, formatter))
                        did = True
                        in_section = None
                    else:
                        lex = line.replace("```", "")
                        if lex != "":
                            lexer_name = lex
                        in_section = []
                    continue
                if in_section is not None:
                    in_section.append(line)
                    continue
                lines.append(line)
            if in_section is not None:
                raise Exception("unclosed code section: {}".format(f))
            with open(output_file, 'w') as out_file:
                out_file.write("\n".join(lines))
            files.append(output_file)
        idx += 1
        if guessed:
            _warn("guessed lexer in {}".format(f))
    if did:
        css += "\n{}".format(formatter_css)
    return files, css


def _mdtoslides(args):
    """Convert markdown to pdf slides."""
    inputs = list(_list_files(".", ignores=[os.path.relpath(args.output)]))
    if len(inputs) == 0:
        print("no markdown files found in directory")
        return
    if not os.path.exists(args.output):
        print("making output directory")
        os.mkdir(args.output)
    css = _CSS
    if os.path.exists(args.css):
        print("using custom css")
        with open(args.css, 'r') as f:
            read_css = f.read()
            if args.merge_css:
                css = "{}\n{}".format(css, read_css)
            else:
                css = read_css
    if args.no_highlighting:
        files = inputs
    else:
        files, css = _pygments(args, inputs, css)
    print("preparing...")
    for f in os.listdir(args.output):
        if f == _STATE:
            continue
        _, ext = os.path.splitext(f)
        if ext == ".pdf":
            continue
        if os.path.join(args.output, f) in files:
            continue
        os.remove(os.path.join(args.output, f))
    idx = 0
    html_index = {}
    state = {}
    cwd = os.getcwd()
    l_files = len(files)
    for f in sorted(files):
        print("converting " + f)
        str_id = str(idx)
        file_name = os.path.join(args.output, str_id + ".html")
        html_index[idx] = file_name
        uname = _path_cleanup(f)
        dname = f.split("/")
        dname = "/".join(dname[0:len(dname)-1]).strip()
        dname = _path_cleanup(dname)
        if not dname:
            dname = _ROOT
        with open(file_name, 'w') as w:
            _write_html(w, css, uname, dname, str_id, f, idx + 1, l_files)
        p = subprocess.Popen(["md5sum", file_name], stdout=subprocess.PIPE)
        out, err = p.communicate()
        hashed = ""
        if out:
            hashed = out.decode("utf-8").strip().split(" ")[0]
        if err:
            raise Exception("unable to md5sum: {}".format(err))
        state[str(idx)] = hashed
        idx += 1
    pdf_files = []
    prev = {}
    state_file = os.path.join(args.output, _STATE)
    if os.path.exists(state_file):
        with open(state_file, 'r') as f:
            prev = json.loads(f.read())
    with open(os.devnull) as dn:
        for i in sorted(html_index.keys()):
            f = html_index[i]
            pdf_file = f + ".pdf"
            pdf_files.append(pdf_file)
            str_i = str(i)
            if str_i in state and str_i in prev:
                if state[str_i] == prev[str_i]:
                    continue
            if os.path.exists(pdf_file):
                os.remove(pdf_file)
            with open(f, 'r') as h:
                print("building " + pdf_file)
                margins = []
                for x in ["--margin-{}".format(x) for x in ["top",
                                                            "left",
                                                            "right",
                                                            "bottom"]]:
                    margins += [x, "0"]
                r = subprocess.call([_HTMLTOPDF] + margins + [
                                     "-O",
                                     "landscape",
                                     "-",
                                     pdf_file],
                                    stdin=h,
                                    stderr=dn)
                if r != 0:
                    raise Exception("html to pdf failed")
    if len(pdf_files) != idx:
        print('WARNING: md -> html -> pdf mismatch')
    out_file = os.path.join(args.output, "output.pdf")
    cmd = [_PDFUNITE] + pdf_files + [out_file]
    r = subprocess.call(cmd)
    if r != 0:
        raise Exception("pdf unite failed")
    with open(state_file, 'w') as f:
        f.write(json.dumps(state))
    print("completed")


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("--output", default="bin/")
    parser.add_argument("--css", default="slides.css")
    parser.add_argument("--merge-css", action="store_true")
    parser.add_argument("--no-highlighting", action="store_true")
    parser.add_argument("--print-css", action="store_true")
    args = parser.parse_args()
    if args.print_css:
        print(_CSS)
        return
    commands = [_error("{} is not installed".format(x)) for x in _CMDS
                if shutil.which(x) is None]
    checks = [_MISSING_PACKAGE] + [True for x in commands]
    if any([x for x in checks if x or x is None]):
        exit(1)
    try:
        _mdtoslides(args)
    except Exception as e:
        print("unable to process")
        print(e)
        exit(1)


if __name__ == "__main__":
    main()
