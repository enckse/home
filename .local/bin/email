#!/usr/bin/python3
"""Email handling."""
import common
import sys
import os
import time
import datetime
import subprocess
import mail


def _section(log, mode, info):
    log.write("====================\n")
    log.write("{}: {}\n".format(mode, info))
    log.write("====================\n")
    log.flush()


def _run_logged(cmd, log):
    """Run a logged command."""
    subprocess.call(cmd, stdout=log, stderr=log)
    log.flush()


def _mbsync(env):
    """Run mbsync."""
    if subprocess.call(["pidof", "mbsync"]) == 0:
        print("mbsync already running")
        return False
    now = datetime.datetime.now()
    dt = now.strftime("%Y-%m-%d")
    log_file = os.path.join(env.USER_TMP, "mbsync.{}.log".format(dt))
    mode = 'w'
    created = True
    if os.path.exists(log_file):
        mode = 'a'
        created = False
    if not created:
        import shutil
        shutil.rmtree(env.INDEX_DIR)
    for d in [env.INDEX_DIR, env.INDEX_CUR, env.INDEX_NEW]:
        if not os.path.exists(d):
            os.mkdir(d)
    with open(log_file, mode) as f:
        _section(f, "BEGIN", now)
        _run_logged(["mbsync", "-aV"], f)
        _section(f, "INDEX, created", created)
        if created:
            _clean_index(env)
        _run_logged(["notmuch", "new"], f)
        _section(f, "END", now)
    return True


def _clean_index(env):
    """Cleanup the index."""
    for f in os.listdir(env.INDEX_CUR):
        fpath = os.path.join(env.INDEX_CUR, f)
        if os.path.islink(fpath):
            os.unlink(fpath)


def _imap(env, queue=False):
    """Run imap sync."""
    if not common.is_online():
        return
    result = _mbsync(env)
    if queue and not result:
        count = 0
        while count < 30:
            time.sleep(1)
            if _mbsync(env):
                return
            count += 1


def _client(env, account):
    """Connect an email client."""
    if account not in mail.ACCOUNTS:
        return
    time.sleep(0.5)
    muttrc = os.path.join(env.HOME, ".mutt", "{}.muttrc".format(account))
    subprocess.call(["mutt", "-F", muttrc], cwd=env.XDG_DOWNLOAD_DIR)
    time.sleep(0.25)


def _search(env, terms):
    """Search terms."""
    out, err = common.get_output_or_error(["notmuch",
                                           "search",
                                           "--output=files"] + terms)
    if err is not None:
        print('search failed')
        return
    _clean_index(env)
    found = False
    for f in [x.strip() for x in out.decode("utf-8").split("\n")]:
        if not f:
            continue
        bname = os.path.basename(f)
        lname = os.path.join(env.INDEX_CUR, bname)
        os.symlink(f, lname)
        found = True
    if not found:
        print("nothing found...")


def main():
    """Program entry."""
    args = sys.argv
    env = common.read_env()
    env.INDEX_DIR = os.path.join(env.MAIL_DIR, "Indexed")
    env.INDEX_CUR = os.path.join(env.INDEX_DIR, "cur")
    env.INDEX_NEW = os.path.join(env.INDEX_DIR, "new")
    if len(args) <= 1:
        _imap(env)
        return
    commands = args[1:]
    cmd = commands[0]
    has_sub = False
    if len(commands) > 1:
        has_sub = True
        commands = commands[1:]
    if cmd == "client":
        if not has_sub:
            print("client required")
            return
        _client(env, commands[0])
    elif cmd == "search":
        if not has_sub:
            print("search term(s) required")
            return
        _search(env, commands)
    elif cmd == "queue":
        _imap(env, queue=True)
    else:
        print("unknown command")


if __name__ == "__main__":
    main()
