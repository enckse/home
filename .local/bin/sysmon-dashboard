#!/bin/bash
NORMAL="\033[0m"
PROBLEM="\033[1;31m"
SLEEP=60

_runcmd() {
    if [ -z "$2" ]; then
        echo "no command"
        exit 1
    fi
    ssh $1 -o BatchMode=yes -o ConnectTimeout=10 ${@:2} 2>/dev/null
    return $?
}

_keyvalues() {
    local key value f cnt idx tree
    cnt=$(echo "$@" | tr ' ' '\n' | wc -l)
    idx=1
    for f in $(echo "$@"); do
        tree="├"
        if [ $idx -eq $cnt ]; then
            tree="└"
        fi
        key=$(echo "$f" | cut -d ":" -f 1)
        value=$(echo "$f" | cut -d ":" -f 2- | sed "s/\_/ /g" | sed "s/,//g")
        printf "          $tree─ %-6s: %s\n" "$key" "$value"
        idx=$((idx+1))
    done
}

_server() {
    local online color stopping data sysmon red normal
    stopping=0
    online="online ┐"
    data=$(_runcmd $1 "uptime -p | sed 's/ /_/g' | sed 's/^/uptime:/g';
date +%Y-%m-%dT%H-%M-%S | sed 's/^/polled:/g';\
cat /etc/debian_version | sed 's/^/debian:/g';\
cat /var/log/apt/history.log | sed '1s/^/Start-Date: Unknown /' | grep '^Start-Date: ' | cut -d ' ' -f 2 | tail -n 1 | sed 's/^/aptrun:/g';
uname -r -v | cut -d ' ' -f 1,5 | sed 's/ / (/g' | sed 's/$/)/g' | sed 's/ /_/g' | sed 's/^/kernel:/g';\
cat /var/log/sysmon.log.* | cut -d ' ' -f 2 | sed 's/://g' | grep -v '^$' | sed 's/^/sysmon:/g' | sort -u")
    if [ $? -eq 0 ]; then
        color="$NORMAL"
    else
        color="$PROBLEM"
        online="offline"
        stopping=1
    fi
    echo -e "$color└─ $online$NORMAL"
    if [ $stopping -gt 0 ]; then
        return
    fi
    sysmon=$(_keyvalues $(echo "$data" | grep "^sysmon:"))
    if [ ! -z "$sysmon" ]; then
        red=$(tput setaf 1)
        normal=$(tput sgr0)
        data="$data
warnings:${red}┐${normal}"
    fi
    _keyvalues $(echo "$data" | grep -v "^sysmon:")
    if [ -z "$sysmon" ]; then
        return
    fi
    sysmon=$(echo "$sysmon" | sed "s/^/             /g" | sed "s/sysmon: //g")
    echo -e "$PROBLEM$sysmon$NORMAL"
}

_process() {
    echo
    echo " $1"
    _server $1 | sed "s/^/  /g"
}

if [ -z "$1" ]; then
    echo "no systems given"
    exit 1
fi

while [ 1 -eq 1 ]; do
    clear
    date +%Y-%m-%dT%H-%M-%S
    for s in $(echo $@ | tr ' ' '\n' | sort -u); do
        _process $s
    done
    echo
    echo "[enter] to refresh now, else waiting $SLEEP seconds"
    read -t $SLEEP
done
