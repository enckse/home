#!/usr/bin/python3
import common
import argparse
import os
import tempfile
import subprocess


_SERVER_MUSIC = "store/Home/Music"

_PURGE = ["mv",
          "cp",
          "rm",
          "clear",
          "history",
          "exit",
          "mkdir",
          "vim",
          "ls"
          "manage",
          "notes",
          "pkg-deb",
          "pkg-pool",
          "pkg-upload",
          "less",
          "qalc",
          "wsw",
          "pkill",
          "i3",
          "goimports",
          "totp",
          "volume",
          "locking"]


_DEPRECATED = ["aptitude"]
_NAME_IGNORES = [".bash_history", "pacman", "reboot", "poweroff"]
_BY_SIZE = {
        "ssh": 3,
        "scp": 3,
        "git": 2,
        "cat": 2,
        "firefox": 2,
        "apt-get": 3,
        "apt-cache": 3,
        "aptitude": 2,
        "dpkg": 2,
        "find": 2,
        "apt": 2,
        "cd": 2,
        "ps": 2,
        "man": 2,
        "sudo": 2,
        "python": 2,
        "touch": 2,
        "grep": 2,
        "scp": 4,
        "kill": 3,
        "diff": 4,
        "ls": 2,
        "python3": 2,
        "echo": 2,
        "schroot": 3,
        "source": 2,
        "unzip": 2,
        "make": 2,
        "python2": 2}

_KNOWN = {
        "aptcache": ("apt-cache", "search", 3),
        "aptsearch": ("apt", "search", 3),
        "tarxf": ("tar", "xf", 3),
        "tarczvf": ("tar", "czvf", 4)
        }

_GIT_COMMANDS = {
    3: ["rm", "grep", "add", "checkout", "log", "diff", "show", "revert"],
    4: ["commit", "bisect", "checkout"]
}

_STARTS_WITH = ["pass-", "git commit -am", "vim ", "sudo git "]

for gc in _GIT_COMMANDS:
    _values = _GIT_COMMANDS[gc]
    for g in _values:
        _KNOWN["git{}".format(g)] = ("git", g, gc)


def _history_dryrun(message, line):
    """Report history dryrun purges."""
    print("{} -> ({})".format(line, message))
    return 1


def _history(env, purge):
    """Manage bash history."""
    hist = os.path.join(env.HOME, ".bash_history")
    tmp = hist + ".tmp"
    lines = []
    cnt = 0
    strip_lines = []
    with open(hist, 'r') as f:
        for line in f:
            ls = line.strip()
            adding = True
            parts = ls.split(" ")
            lparts = len(parts)
            if len(ls) < 11:
                adding = False
                cnt += _history_dryrun("less than 10 chars", ls)
            for p in _PURGE:
                if ls.startswith("{} ".format(p)) or ls == p:
                    adding = False
                    cnt += _history_dryrun(p + " blacklisted", ls)
                    break
            for i in _NAME_IGNORES:
                if i in ls:
                    adding = False
                    cnt += _history_dryrun("ignored " + i, ls)
            for b in _BY_SIZE:
                sized = _BY_SIZE[b]
                if lparts <= sized:
                    if parts[0] == b:
                        adding = False
                        msg = "short command {} ({})".format(b, str(sized))
                        cnt += _history_dryrun(msg, ls)
                        break
            for s in _STARTS_WITH:
                if ls.startswith(s):
                    adding = False
                    cnt += _history_dryrun("startswith {}".format(s), ls)
            for k in _KNOWN:
                known = _KNOWN[k]
                if lparts == known[2]:
                    if parts[0] == known[0]:
                        if parts[1] == known[1]:
                            adding = False
                            msg = "known command {}".format(known)
                            cnt += _history_dryrun(msg, ls)
            for d in _DEPRECATED:
                check_part = None
                check_part = parts[0]
                if lparts >= 2:
                    if parts[0] == "sudo":
                        check_part = parts[1]
                if d == check_part:
                    adding = False
                    msg = "{} is deprecated".format(check_part)
                    cnt += _history_dryrun(msg, ls)
            if line.strip() in strip_lines:
                cnt += _history_dryrun("line not unique when stripped", ls)
                adding = False
            if line in lines:
                cnt += _history_dryrun("line not unique", ls)
                lines = [x for x in lines if x != line]
            if adding:
                lines.append(line)
                strip_lines.append(line.strip())
    if purge:
        with open(tmp, 'w') as f:
            for l in lines:
                f.write(l)
        os.remove(hist)
        os.rename(tmp, hist)
    print("purging: " + str(cnt))
    if not purge:
        print("^^^ DRYRUN ^^^")


def _music(env):
    """Synchronize music."""
    music_file = os.path.join(env.HOME_XDG, "music")
    includes = []
    chars = []
    music_dir = os.path.join(env.MANAGED, "music")
    with open(music_file, 'r') as f:
        with tempfile.NamedTemporaryFile() as tmp:
            for l in f:
                strip = l.strip()
                lower = strip.lower()
                c = None
                for pre in ["the"]:
                    if lower.startswith("{} ".format(pre)):
                        c = strip[len(pre) + 1:][0]
                if c is None:
                    c = strip[0]
                c = c + "/"
                obj = c + strip + "/"
                subprocess.call(["ssh",
                                 env.BASE_SERVER,
                                 "find",
                                 "'{}'".format(os.path.join(_SERVER_MUSIC,
                                                            obj)),
                                 "-type",
                                 "f"],
                                stdout=tmp)
            with open(tmp.name) as t:
                for l in t.readlines():
                    line = l.strip()
                    if line.endswith(".mp3") or line.endswith(".MP3"):
                        includes.append(line.replace(_SERVER_MUSIC + "/", ""))
    with tempfile.NamedTemporaryFile() as tmp:
        for l in includes:
            tmp.write((l + "\n").encode("UTF-8"))
        tmp.flush()
        subprocess.call(["rsync",
                         "-av",
                         "--files-from",
                         tmp.name,
                         env.BASE_SERVER + ":{}/".format(_SERVER_MUSIC),
                         music_dir])
    removals = []
    for r, _, files in os.walk(music_dir):
        for f in files:
            file_path = os.path.join(r, f)
            path = file_path.replace(music_dir, "")[1:]
            if path not in includes:
                removals.append(file_path)
    if len(removals) > 0:
        for r in removals:
            print("removing: {}".format(r))
            os.remove(r)


def _git_updates(env, update):
    if len(update) > 1:
        print("one update per run")
        return
    target = None
    if len(update) == 1:
        target = update[0]
    if target is None or target == "all":
        target = ""
    for r, f, d in os.walk(os.path.join(env.PERM_LOCATION, target)):
        git_dir = os.path.join(r, ".git")
        if os.path.exists(git_dir):
            print("")
            print(r)
            print("")
            subprocess.call(["git", "-C", r, "pull"])
            print("")


def _schroots(env, cmds):
    """Run commands against all schroots."""
    for l in sorted(os.listdir(env.SCHROOTS)):
        for c in cmds:
            print("\n\n  ===> {} -> {}\n\n".format(l, c))
            subprocess.call(["sudo",
                             "schroot",
                             "-c",
                             "source:{}".format(l), "--"] + c)


def _exit(msg):
    print(msg)
    exit(1)

def _parse_subcommand(unknowns, default, options):
    if len(unknowns) == 0:
        return default
    if len(unknowns) != 1:
        _exit("unknown subcommand: arguments {}".format(unknowns))
    cmd = unknowns[0]
    if cmd in options:
        return options.index(cmd)
    else:
        _exit("unknown subcommand: {}".format(cmd))


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("command")
    args, unknowns = parser.parse_known_args()
    env = common.read_env()
    if args.command == "music":
        _music(env)
    elif args.command == "schroots":
        cmd = [["apt"] + [x] for x in ["update",
                                       "upgrade",
                                       "autoremove",
                                       "autoclean"]]
        if len(unknowns) > 0:
            cmd = [unknowns]
        _schroots(env, cmd)
    elif args.command == "history":
        sub = _parse_subcommand(unknowns, 0, ["dryrun", "purge"])
        _history(env, sub > 0)
    elif args.command == "history-purge":
        _history(env, True)
    elif args.command == "git":
        _git_updates(env, unknowns)
    else:
        print("unknown command")


if __name__ == "__main__":
    main()
