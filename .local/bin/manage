#!/usr/bin/python3
import common
import argparse
import os
import tempfile
import subprocess


_SERVER_MUSIC = "store/Home/Media/Music"

_PURGE = ["mv",
          "cp",
          "rm",
          "clear",
          "exit",
          "mkdir",
          "vim",
          "ls"
          "manage",
          "notes",
          "pkg-deb",
          "pkg-pool",
          "pkg-upload",
          "less",
          "qalc",
          "wsw",
          "pkill",
          "i3",
          "volume",
          "locking"]


_DEPRECATED = ["aptitude"]
_NAME_IGNORES = [".bash_history", "pacman", "reboot", "poweroff"]
_BY_SIZE = {
        "ssh": 3,
        "scp": 3,
        "git": 2,
        "cat": 2,
        "firefox": 2,
        "apt-get": 3,
        "apt-cache": 3,
        "aptitude": 2,
        "dpkg": 2,
        "find": 2,
        "apt": 2,
        "cd": 2,
        "ps": 2,
        "man": 2,
        "sudo": 2,
        "python": 2,
        "touch": 2,
        "scp": 4,
        "kill": 3,
        "diff": 4,
        "ls": 2,
        "python3": 2,
        "echo": 2,
        "schroot": 3,
        "source": 2,
        "unzip": 2,
        "make": 2,
        "python2": 2}

_KNOWN = {
        "aptcache": ("apt-cache", "search", 3),
        "aptsearch": ("apt", "search", 3),
        "tarxf": ("tar", "xf", 3),
        "tarczvf": ("tar", "czvf", 4)
        }

_GIT_COMMANDS = {
    3: ["rm", "grep", "add", "checkout", "log", "diff", "show", "revert"],
    4: ["commit", "bisect", "checkout"]
}

_STARTS_WITH = ["pass-"]

for gc in _GIT_COMMANDS:
    _values = _GIT_COMMANDS[gc]
    for g in _values:
        _KNOWN["git{}".format(g)] = ("git", g, gc)

def _history_dryrun(message, line):
    """Report history dryrun purges."""
    print("{} -> ({})".format(line, message))
    return 1


def _history(env, purge):
    """Manage bash history."""
    hist = os.path.join(env.HOME, ".bash_history")
    tmp = hist + ".tmp"
    lines = []
    cnt = 0
    strip_lines = []
    with open(hist, 'r') as f:
        for line in f:
            ls = line.strip()
            adding = True
            parts = ls.split(" ")
            lparts = len(parts)
            if len(ls) < 11:
                adding = False
                cnt += _history_dryrun("less than 10 chars", ls)
            for p in _PURGE:
                if ls.startswith("{} ".format(p)) or ls == p:
                    adding = False
                    cnt += _history_dryrun(p + " blacklisted", ls)
                    break
            for i in _NAME_IGNORES:
                if i in ls:
                    adding = False
                    cnt += _history_dryrun("ignored " + i, ls)
            for b in _BY_SIZE:
                sized = _BY_SIZE[b]
                if lparts <= sized:
                    if parts[0] == b:
                        adding = False
                        msg = "short command {} ({})".format(b, str(sized))
                        cnt += _history_dryrun(msg, ls)
                        break
            for s in _STARTS_WITH:
                if ls.startswith(s):
                    adding = False
                    cnt += _history_dryrun("startswith {}".format(s), ls)
            for k in _KNOWN:
                known = _KNOWN[k]
                if lparts == known[2]:
                    if parts[0] == known[0]:
                        if parts[1] == known[1]:
                            adding = False
                            msg = "known command {}".format(known)
                            cnt += _history_dryrun(msg, ls)
            for d in _DEPRECATED:
                check_part = None
                check_part = parts[0]
                if lparts >= 2:
                    if parts[0] == "sudo":
                        check_part = parts[1]
                if d == check_part:
                    adding = False
                    msg = "{} is deprecated".format(check_part)
                    cnt += _history_dryrun(msg, ls)
            if line.strip() in strip_lines:
                cnt += _history_dryrun("line not unique when stripped", ls)
                adding = False
            if line in lines:
                cnt += _history_dryrun("line not unique", ls)
                lines = [x for x in lines if x != line]
            if adding:
                lines.append(line)
                strip_lines.append(line.strip())
    if purge:
        with open(tmp, 'w') as f:
            for l in lines:
                f.write(l)
        os.remove(hist)
        os.rename(tmp, hist)
    print("purging: " + str(cnt))
    if not purge:
        print("^^^ DRYRUN ^^^")


def _music(env):
    """Synchronize music."""
    music_file = os.path.join(env.HOME_XDG, "music")
    includes = []
    chars = []
    with open(music_file, 'r') as f:
        with tempfile.NamedTemporaryFile() as tmp:
            for l in f:
                strip = l.strip()
                lower = strip.lower()
                c = None
                for pre in ["the", "a"]:
                    if lower.startswith("{} ".format(pre)):
                        c = strip[len(pre) + 1:][0]
                if c is None:
                    c = strip[0]
                c = c + "/"
                obj = c + strip + "/"
                subprocess.call(["ssh",
                                 env.BASE_SERVER,
                                 "find",
                                 "'{}'".format(os.path.join(_SERVER_MUSIC, obj)),
                                 "-type",
                                 "f"],
                                 stdout=tmp)
            with open(tmp.name) as t:
                for l in t.readlines():
                    line = l.strip()
                    if line.endswith(".mp3") or line.endswith(".MP3"):
                        includes.append(line.replace(_SERVER_MUSIC + "/", ""))
    with tempfile.NamedTemporaryFile() as tmp:
        for l in includes:
            tmp.write((l + "\n").encode("UTF-8"))
        tmp.flush()
        subprocess.call(["rsync",
                         "-av",
                         "--files-from",
                         tmp.name,
                         env.BASE_SERVER + ":{}/".format(_SERVER_MUSIC),
                         os.path.join(env.MANAGED, "music"),
                         "--delete-after"])


def _git_updates(env):
    for r, f, d in os.walk(env.PERM_LOCATION):
        if "personal" in r:
            continue
        git_dir = os.path.join(r, ".git")
        if os.path.exists(git_dir):
            print("")
            print(r)
            print("")
            subprocess.call(["git", "-C", r, "pull"])
            print("")


def _schroots(env):
    """Manage schroot updates."""
    for l in sorted(os.listdir(env.SCHROOTS)):
        for command in ["update",
                        "upgrade",
                        "dist-upgrade",
                        "autoremove",
                        "autoclean"]:
            print("\n\n  ===> {} -> {}\n\n".format(l, command))
            subprocess.call(["sudo",
                             "schroot",
                             "-c",
                             "source:{}".format(l),
                             "apt",
                             command])


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("command")
    args = parser.parse_args()
    env = common.read_env()
    if args.command == "music":
        _music(env)
    elif args.command == "schroots":
        _schroots(env)
    elif args.command == "history-dryrun":
        _history(env, False)
    elif args.command == "history-purge":
        _history(env, True)
    elif args.command == "git-update-store":
        _git_updates(env)
    else:
        print("unknown command")


if __name__ == "__main__":
    main()
