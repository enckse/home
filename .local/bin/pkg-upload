#!/usr/bin/python3
"""Debian package uploading."""
import os
import tempfile
import debian
import common
import argparse
import shutil
import subprocess
import urllib.request
import datetime


_REPOS = {"stable": "buster", "unstable": "sid"}
_OPT_DEB = "/opt/debian"
_ARCHIVE = "archive"
_ARCHIVE_DIR = os.path.join(_OPT_DEB, _ARCHIVE)
_SNAP = "snapshot-"
_IS_LOCAL = "local"
_REMOTE = "remote"
_INTERNAL = "internal"
_TARGETS = ["develop", _INTERNAL, _REMOTE]


def _run_ssh(dest, cmd):
    subprocess.call(["ssh", dest] + cmd)


def _run_rsync(args, src, target):
    subprocess.call(["rsync", "-avc"] + args + ["-e", "ssh", src, target])


def _section(begins):
    t = begins
    start = "\n"
    end = ""
    if t is None:
        end = "\n"
        start = ""
        t = "ENDS HERE"
    print("{}===== {} ====={}".format(start, t, end))


def _upload(env, dest, contents, local):
    """Upload the package."""
    if dest:
        target = "{}:{}".format(dest, _OPT_DEB)
    else:
        target = _OPT_DEB
    if not local:
        dirs = {}
        for ck, cv in contents.items():
            for rk, rv in cv.items():
                objs = set([os.path.dirname(x) for x in rv])
                if len(objs) != 1:
                    raise Exception("unable to get unique archive dir")
                dirs[os.path.join(ck, rk)] = list(objs)[0]
        for dk, dv in dirs.items():
            _section("ARCHIVING")
            print("archive: {}".format(dk))
            _run_rsync(["--include", '*/', "--include", '*.deb', "--exclude", '*'],
                       "{}/".format(dv),
                       "{}/{}/{}".format(target, _ARCHIVE, dk))
            _section(None)
        dt = datetime.datetime.now().strftime("{}%Y-%m-%dT%H-%M-%S".format(_SNAP))
        _section("PURGE OLD")
        _run_ssh(dest, ["find",
                        _ARCHIVE_DIR,
                        "-mtime",
                        "90",
                        "-type",
                        "f",
                        "-name",
                        "*.deb",
                        "-exec",
                        "rm",
                        "{}",
                        "\\;"])
        _section(None)
    _section("UPLOADING")
    _run_rsync(["--delete-after"], debian.DISTS, target)
    _section(None)
    print("COMPLETE: {}".format(target))


def _pack(env, pool, objects, components, local):
    """Package pools."""
    print("preparing...")
    repo_contents = {}
    repos = sorted(set([x.repo for x in objects]))
    for r in repos:
        if r not in _REPOS:
            raise Exception("unknown repo")
        codename = _REPOS[r]
        dist = os.path.join("dists", r)
        for comp in components:
            root = os.path.join(dist, comp, "binary-amd64")
            os.makedirs(root)
            flt = [comp]
            if not local:
                flt.append(debian.IS_ALL)
            debs = [x.deb for x in objects if x.repo == r and x.filter in flt]
            held = []
            for d in debs:
                holder = os.path.join(root, d)
                shutil.copyfile(os.path.join(pool, d), holder)
                held.append(holder)
            packages = os.path.join(root, "Packages")
            if comp not in repo_contents:
                repo_contents[comp] = {}
            repo_contents[comp][r] = held
            with open(packages, 'w') as f:
                subprocess.call(["apt-ftparchive", "packages", root], stdout=f)
            old_packages = os.path.join(pool, "{}.{}.packages".format(r, comp))
            if os.path.exists(old_packages):
                res = subprocess.call(["diff", "-u", old_packages, packages])
                if res != 0:
                    print("please review changes to {}:{}".format(r, comp))
                    input()
                    shutil.copyfile(packages, old_packages)
            package_gz = packages + ".gz"
            with open(package_gz, 'w') as f:
                subprocess.call(["gzip",
                                 "-c",
                                 "--keep",
                                 "--force",
                                 "-9",
                                 packages],
                                stdout=f)
        with open(os.path.join(dist, "Date"), 'w') as f:
            subprocess.call(["date", "+%Y-%m-%d-%H-%M-%S"], stdout=f)
        release_file = os.path.join(dist, "Release")
        with open(release_file, 'w') as f:
            obj = {"Suite": r,
                   "Codename": codename,
                   "Components": components}
            for o in obj:
                f.write("{}: {}\n".format(o, obj[o]))
        with open(release_file, 'a') as f:
            subprocess.call(["apt-ftparchive", "release", dist], stdout=f)
        subprocess.call(["gpg",
                         "--clearsign",
                         "--digest-algo",
                         "SHA512",
                         "--local-user",
                         env.DEB_SIGN_KEY,
                         "-o",
                         os.path.join(dist, "InRelease"),
                         release_file])
        subprocess.call(["gpg",
                         "--yes",
                         "-abs",
                         "--local-user",
                         env.DEB_SIGN_KEY,
                         "-o",
                         release_file + ".gpg",
                         release_file])
    return repo_contents


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("target")
    args = parser.parse_args()
    deb_env = common.read_env()
    if not os.path.exists(deb_env.REPOSITORY):
        print("invalid input path")
        return
    mani = os.path.join(deb_env.REPOSITORY, debian.MANIFEST)
    m = debian.parse_manifest(mani)
    t = args.target
    if t == "_list_":
        print(" ".join(_TARGETS))
        return
    if t not in _TARGETS:
        print("unknown target: {}".format(t))
        return
    local = t != _REMOTE
    if local:
        comps = [_IS_LOCAL]
        if t == _INTERNAL:
            mirror = deb_env.BASE_SERVER
        else:
            mirror = None
    else:
        mirror = debian.MIRROR
        comps = sorted(set([x.filter for x in m if x.filter != debian.IS_ALL and x.filter != _IS_LOCAL]))
    tmpd = tempfile.mkdtemp()
    try:
        os.chdir(tmpd)
        contents = _pack(deb_env, deb_env.REPOSITORY, m, comps, local)
        if contents:
            _upload(deb_env, mirror, contents, local)
        shutil.rmtree(tmpd)
    except Exception as e:
        shutil.rmtree(tmpd)
        raise


if __name__ == "__main__":
    main()
