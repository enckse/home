#!/usr/bin/python3
import argparse
import os
import subprocess
import debian
import common

_PREV = ".prev"


def _move(src, dest, manifest):
    """Pool a package."""
    bname = os.path.basename(src)
    to = os.path.join(dest, bname)
    if os.path.exists(to):
        print(bname + " is already deployed")
        return
    name = bname.split("_")[0]
    prevs = False
    checks = []
    operations = []
    for f in os.listdir(dest):
        if f.endswith(_PREV):
            print("removing " + f)
            os.remove(os.path.join(dest, f))
        if not f.endswith(debian.DEB):
            continue
        fname = f.split("_")[0]
        if fname == name:
            if not prevs:
                print("previous version(s) exist")
                prevs = True
            print("  -> " + f)
        else:
            checks.append(f)
    if len(checks) > 0:
        currents = []
        for l in debian.parse_manifest(manifest):
            currents.append(l.deb)
        for c in checks:
            if c not in currents:
                print(c + " is not in a manifest (will be deleted)")
                fpath = os.path.join(dest, c)
                operations.append(["mv", fpath, fpath + _PREV])
    operations.append(["cp", src, dest])
    for o in operations:
        subprocess.call(o)


def _pool(src, dest):
    """Add a package to the pool."""
    valid = True
    if os.path.exists(src):
        if not os.path.isfile(src) or not src.endswith(debian.DEB):
            print("file is not a " + debian.DEB)
            valid = False
    else:
        valid = False
        print("source does not exist")
    manifest = os.path.join(dest, debian.MANIFEST)
    if os.path.exists(dest):
        if os.path.isdir(dest):
            if not os.path.exists(manifest):
                print("invalid directory, not a pool")
                valid = False
        else:
            print("dest is not a directory")
            valid = False
    else:
        valid = False
        print("pool does not exist")
    if not valid:
        return
    _move(src, dest, manifest)


def _rebuild(repo):
    dist = os.path.join(repo, debian.DISTS)
    if not os.path.exists(dist):
        print("no dist folder found?")
        return
    releases = os.listdir(dist)
    output = []
    for r in releases:
        rpath = os.path.join(dist, r)
        repos = []
        for repo in os.listdir(rpath):
            repo_path = os.path.join(rpath, repo)
            if not os.path.isdir(repo_path):
                continue
            repos.append((repo, repo_path))
        debs = {}
        for repo in repos:
            for root, _, files in os.walk(repo[1]):
                for f in files:
                    if not f.endswith(debian.DEB):
                        continue
                    if f not in debs:
                        debs[f] = []
                    debs[f].append(repo[0])
        for k in sorted(debs.keys()):
            obj = debs[k]
            append_to = []
            if len(obj) == len(repos):
                append_to = ["all"]
            else:
                append_to = obj
            for a in append_to:
                output.append(debian.DELIMITER.join([r, a, k]))
    for r in sorted(output):
        print(r)


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("object")
    parser.add_argument("--rebuild", action="store_true")
    args = parser.parse_args()
    if args.rebuild:
        if not os.path.isdir(args.object):
            print('object must be a directory')
            return
        _rebuild(args.object)
        return
    env = common.read_env()
    _pool(args.object, env.REPOSITORY)


if __name__ == "__main__":
    main()
