#!/usr/bin/perl
use strict;
use warnings;
use Sys::Hostname;

my $cache = $ENV{"HOME"} . "/.cache/backup/";
mkdir $cache if !-d $cache;
my $tmp = "/tmp/backup/";
mkdir $tmp if !-d $tmp;
my $check = `date +%Y-%m-%d.%H`;
chomp $check;
$check = $tmp . $check;
my $notify    = $ENV{"NOTIFY_MESSAGES"} . "/backup";
my $hashes    = $cache . "hashes";
my $lasthash  = $hashes . ".prev";
my $backuplog = $check . ".log";
my $server    = $ENV{"SERVER"};
my $host      = hostname;

my $mirrors = $ENV{"HOME"} . "/store/personal/mirror/";
my $repo    = $ENV{"HOME"} . "/store/personal/private/";

sub dryrun {
    system("touch $hashes $lasthash");
    if ( -e $check ) {
        return;
    }
    for ( ( $mirrors, $repo ) ) {
        system(
"find $_ -type f -printf '%p.%TY-%Tm-%TdT%TH:%TM:%TS\n' | grep -v '${mirrors}notebook' | sort >> $hashes"
        );
    }
    system("echo 'backup:required' > $notify")
      if system("diff -u $hashes $lasthash > $backuplog") != 0;
    system("mv $hashes $lasthash");
}

sub clean {
    system("rm -f $notify");
}

if (@ARGV) {
    my $mode = shift @ARGV;
    if ( $mode eq "status" ) {
        dryrun;
        system("touch $check");
        exit 0;
    }
    elsif ( $mode eq "clear" ) {
        clean;
        exit 0;
    }
    else {
        die "unknown command: $mode";
    }
}

die "backup system unavailable"
  if system(
"ssh -o BatchMode=yes -o ConnectTimeout=5 $server echo is-online > /dev/null"
  );

print "\n=> cleaning up cache\n";
system("find $cache -type f -mtime +30 -exec rm {} \\;");

print "backing up mirrors\n";
for (`ls $mirrors`) {
    chomp;
    my $prefix = "";
    if ( $_ eq "notebook" ) {
        $prefix = ".$host";
    }
    system(
"rsync -avcr --delete-after $mirrors/$_/ $server:~/store/Active/Drop/Mirror/$prefix$_ | sed 's/^/$_ ->    /g'"
    );
}

if ( ! $ENV{"IS_DESKTOP"} ) {
    print "\n=> backing up git repos\n";
    my $zippass = `PASSWORD_STORE_DIR=~/.pass/personal pass show keys/zips`;
    chomp $zippass;
    my $commit = `git -C $repo log --format=%h -n 1`;
    chomp $commit;
    my $zipfile = $cache . "private.$commit.7z";
    if ( !-e $zipfile ) {
        system("find $cache -type f -name '*.7z' -delete");
        system(
"7z a -spf -p$zippass $zipfile \$(find $repo -type f | grep -v '\\.git')"
        );
        system(
"perl ~/.local/lib/inbox.pl --input $zipfile --subject 'private.zip'"
        );
    }
}

system("rm -f $notify $check");
dryrun;

print "\n=> syncing profiles\n";
system(
"ssh $server 'find ~/store/Active/Drop/Profiles -mindepth 1 -maxdepth 1 -mtime +7 -name '*$host*' -type d -exec rm -rf {} \\;'"
);

my $profile = `date +%Y-%m-%dT%H-%M-%S`;
chomp $profile;
$profile = "~/store/Active/Drop/Profiles/$host.$profile";
system("ssh $server 'mkdir -p $profile'");
$profile = "$server:$profile";
my $timers = $cache . "systemd.timers";
system("systemctl list-timers > $timers");
my $units = $cache . "systemd.units";
system("systemctl list-units > $units");
my $packages = $cache . "packages";
system("pacman -Qqe > $packages");

for ( ( "~/.mozilla", "~/.bash_history", $packages, $timers, $units ) ) {
    my $target = `basename $_  | sed "s/^\\.//g"`;
    chomp $target;
    print("    -> sending $_ to $profile/$target\n");
    system("rsync -ar $_ $profile/$target | sed 's/^/$target ->    /g'");
}

print "\n=> sending backups\n";
if ( system("exit \$(ls $cache | grep backup.tar.gz | wc -l)") ) {
    system("scp $cache*.backup.tar.gz $server:~/store/Active/Drop/Profiles/");
    system("rm -f $cache*.backup.tar.gz");
}
clean;
