#!/usr/bin/python
"""dmenu-wrapper to handle using urls, searching, apps."""
import csv
import os
import subprocess
import argparse
import pickle

# Call to make to dmenu
_DMENU_CALL = """#!//bin/bash
_call() {
    local _results=$(echo {CACHE} | tr ' ' '\\n' | dmenu {ARGS} && echo $?)
    if [ ! -z \"$_results\" ]; then
        echo \"$_results\" | \
                head -n 1 | \
                {DMENU_WRAPPER} --intercept | \
                ${SHELL:-\"/bin/sh\" } &
    fi
}

_call"""

_TLDS = ['com', 'network', 'org', 'mil', 'net', 'edu', 'gov', 'io', 'info']
_SEARCH = "https://www.duckduckgo.com/?q={}"

# pickle caching object
_CACHE_URLS = "urls"
_CACHE_LIST = "list"


def _read_csv(csv_file):
    """Read csv of urls."""
    with open(csv_file, 'r') as f:
        reader = csv.reader(f)
        results = {}
        group_sets = {}
        for line in reader:
            if len(line) != 4:
                print("invalid csv (shortcut, url, args, groups)")
                exit(1)
            shortcut = line[0]
            url = line[1]
            args = line[2]
            groups = line[3]
            if not args:
                args = ""
            if not groups:
                groups = ""
            if not url or len(url.strip()) == 0:
                print('invalid url')
                exit(1)
            if not shortcut or len(shortcut.strip()) == 0:
                print('invalid shortcut')
            grouping = []
            use_args = [x for x in args.split(" ") if len(x.strip()) > 0]
            for g in [x for x in groups.split(" ") if len(x.strip()) > 0]:
                if g not in group_sets:
                    group_sets[g] = []
                group_sets[g].append((url, use_args))
                grouping += g
            results[shortcut] = ("'{}'".format(url), use_args)
        for g in group_sets:
            subs = group_sets[g]
            urls = []
            args = []
            for u in subs:
                urls.append(u[0])
                for a in u[1]:
                    args.append(a)
            results[g] = ("'" + "' '".join(urls) + "'", args)
        return results


def _get_temp_name(temp_dir, dur):
    """Get the location of the dmenu entry cache."""
    import datetime
    now = datetime.datetime.now()
    dur = int(dur * round(float(now.minute)/dur))
    name = ".dmenu.{}.{}.{}.{}.{}".format(now.year,
                                          now.month,
                                          now.day,
                                          now.hour,
                                          dur)
    return os.path.join(temp_dir, name)


def _is_valid_url(url):
    """Simple validity check for url."""
    for tld in _TLDS:
        if '.{}'.format(tld) in url:
            return url
    return None


def _check_chars(url):
    """Simple character scan on url."""
    valid = True
    if len(url) == 0:
        valid = False
    for c in url:
        if c.isalnum() or c in ['.', ':', '/']:
            continue
        if not valid:
            break
        valid = False
    return valid


def _intercepting(args, unknown):
    """Intercepting calls."""
    import sys
    import urllib.parse
    inputs = sys.stdin.read().strip()
    cache_file = _get_temp_name(args.temp, args.duration)
    urls = None
    if os.path.exists(cache_file):
        with open(cache_file, 'rb') as f:
            urls = pickle.load(f)[_CACHE_URLS]
    if urls is None:
        urls = _read_csv(args.urls)
    if inputs in args.list:
        # we know how to handle this from shell
        print(inputs)
        return
    calling = None
    if inputs in urls.keys():
        # it's a url, follow it
        obj = urls[inputs]
        addresses = obj[0]
        use_args = obj[1]
        calling = "{} {}".format(" ".join(use_args), addresses)
    if calling is None:
        # handle urls
        if _check_chars(inputs):
            calling = _is_valid_url(inputs)
    if calling is None:
        if "." in inputs:
            addr = inputs.split(".")
            if len(addr) >= 4:
                invalid = False
                for i in [addr[0], addr[1], addr[2], addr[3]]:
                    alpha = [x for x in i if (x >= 'a' and x <= 'z') or
                             (x >= 'A' and X <= 'Z')]
                    if len(alpha) > 0:
                        invalid = True
                        break
                if not invalid:
                    calling = inputs
    if calling is None:
        # handle search
        searching = inputs
        if searching.lower().startswith("search "):
            searching = searching[7:]
        calling = _SEARCH.format(urllib.parse.quote(searching))
    if calling is not None:
        print("{} {}".format(args.browser, calling))
        return
    print(inputs)


def _producing(args, unknown):
    """Producing a dmenu list."""
    cache_file = _get_temp_name(args.temp, args.duration)
    use_list = None
    if not os.path.exists(cache_file):
        urls = _read_csv(args.urls)
        obj = {}
        obj[_CACHE_URLS] = urls
        use_list = list(urls.keys()) + args.list
        obj[_CACHE_LIST] = use_list
        with open(cache_file, 'wb') as f:
            pickle.dump(obj, f)
    if use_list is None:
        with open(cache_file, 'rb') as f:
            use_list = pickle.load(f)[_CACHE_LIST]
    replacing = {}
    replacing["CACHE"] = " ".join(use_list)
    replacing["ARGS"] = " ".join(unknown)
    replacing["DMENU_WRAPPER"] = args.dmenu_wrapper
    cmd = _DMENU_CALL
    for r in replacing:
        cmd = cmd.replace("{" + r + "}", replacing[r])
    subprocess.call(cmd, shell=True)


def main():
    """Main entry."""
    parser = argparse.ArgumentParser("a dmenu wrapper")
    parser.add_argument("--dmenu-wrapper", type=str, default="dmenu-local",
                        help="dmenu local call")
    parser.add_argument("--list", type=str, default=None,
                        help="list of commands to send to dmenu")
    parser.add_argument("--temp", type=str, default="/tmp/",
                        help="working area")
    parser.add_argument("--intercept", action="store_true",
                        help="intercept dmenu outputs")
    parser.add_argument("--urls", type=str, default=None,
                        help="csv of urls to read")
    parser.add_argument("--browser", type=str, default=None,
                        help="browser for urls")
    parser.add_argument("--duration", type=int, default=30,
                        help="caching duration")
    args, unknown = parser.parse_known_args()
    if not args.browser or not os.path.exists(args.browser):
        print('browser does not exist')
        exit(1)
    if args.list is None:
        args.list = ""
    args.list = args.list.split(" ")
    if not os.path.exists(args.temp):
        print("no temp directory exists")
        exit(1)
    if args.urls:
        if not os.path.exists(args.urls):
            print("url path does not exist")
            exit(1)
    if args.intercept:
        _intercepting(args, unknown)
    else:
        _producing(args, unknown)


if __name__ == "__main__":
    main()
