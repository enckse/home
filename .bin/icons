#!/usr/bin/python
import subprocess
import os
import signal
import datetime
import time
import json
from subprocess import check_output
import threading

devnull = open(os.devnull, 'w')

_HOME = "/home/enck/"
_HOME_TMP = _HOME + ".tmp/"


def _get_socket():
    import socket
    import struct
    socket_path = subprocess.check_output(['i3', '--get-socketpath'], close_fds=True, universal_newlines=True).strip()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(socket_path)
    pay = '["window"]'.encode("utf-8")
    s = struct.pack('=II', len(pay), 2)
    sending = "i3-ipc".encode('utf-8') + s + pay
    sock.sendall(sending)
    return sock

def workspacing():
    """Handles workspace naming."""
    date = str(datetime.datetime.now()).replace(":", "-").replace(" ", "_").replace(".", "_")
    sock = None
    success = True
    while True:
        try:
            if sock is None:
                sock = _get_socket()
            data = sock.recv(1024).decode("utf-8", 'ignore')
            on_change()
            success = True
        except Exception as e:
            if sock:
                sock.close()
            with open(_HOME_TMP + date + ".tray.log", "a") as f:
                sock = None
                if success:
                    f.write("error")
                    f.write(str(e))
                    success = False
                else:
                    f.write("still broken")
                f.write("\n")
            time.sleep(5)

def main():
    """Entry point."""
    workspaces = threading.Thread(target=workspacing)
    workspaces.daemon = True
    workspaces.start()
    path = os.path.join(_HOME, ".config", "icons")
    i = []

def _is_active():
    for proc in ["weechat"]:
        pid = get_pid(proc)
        if pid < 0:
            continue
        if not os.path.exists(_HOME_TMP + proc + ".ready"):
            continue
        os.kill(pid, signal.SIGUSR2)

def get_pid(name):
    """Get pid."""
    try:
        pid = check_output(["pidof", name]).decode("utf-8").strip()
        val = int(pid)
        return val
    except:
        return -1

def uncurl(obj):
    """uncurl nest nodes down."""
    children = []
    for node in obj["nodes"]:
        for opened in uncurl(node):
            children.append(opened)
        children.append(node)
    return children


def on_change():
    """on interested changes, call this."""
    value = check_output(["i3-msg", "-t", "get_tree"])
    j = json.loads(value)
    workspaces = _get_workspaces(j)
    _rename_workspaces(workspaces)
    _is_active()


def _get_workspaces(j):
    """Get workspaces."""
    matched = {}
    for node in uncurl(j):
        if "num" in node and "name" in node:
            n = node["num"]
            name = node["name"]
            if n and n >= 1:
                children = []
                for c in uncurl(node):
                    if "window_properties" in c:
                        props = c["window_properties"]
                        if "class" in props:
                            classed = props["class"]
                            children.append(classed)
                matched[n] = (name, children)
    return matched

def _rename_workspaces(workspaces):
    """rename a workspace."""
    for k in workspaces:
        vals = workspaces[k]
        if len(vals[1]) == 0:
            named = str(k)
        else:
            named = ",".join([x[0:20].lower().split(" ")[0] for x in vals[1]])
            named = str(k) + ":" + named
        subprocess.call(["i3-msg",
                         "rename workspace \"{}\" to \"{}\"".format(vals[0], named)],
                         stdout=devnull,
                         stderr=subprocess.STDOUT)


if __name__ == "__main__":
    main()
