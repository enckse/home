#!/usr/bin/python
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GObject
import subprocess
import os
import signal
import time
import json
import hashlib
from subprocess import check_output
import threading

devnull = open(os.devnull, 'w')

_HOME = "/home/enck/"
_HOME_TMP = _HOME + ".tmp/"
_IS_UNLOCK = 0
_IS_SUSPEND = 1
_BRIGHTNESS = 'xrandr --current --verbose | grep "Brightness" | cut -d ":" -f 2 | sed "s/0\.//g" | sed "s/1\.0/100/g" | tail -n 1 | awk \'{printf "%3.0f", $1}\' | sed "s/^[ \t]*//g"'
_LOCKED = """
#!/bin/bash
source """ + _HOME + """.bin/common
if [ -e $DISPLAY_UN ]; then
    echo """ + str(_IS_UNLOCK) + """
else
    if [ -e $DISPLAY_EN ]; then
        echo """ + str(_IS_SUSPEND) + """
    else
        echo 2
    fi
fi
"""

def _call(command):
    """Make a call, get change (else None)."""
    try:
        ret = subprocess.check_output(command, shell=True, executable='/bin/bash').decode("ascii").strip()
        return int(ret)
    except Exception as e:
        pass
    return None

def _locked(val):
    """Get locking image."""
    img = "display"
    if val == _IS_UNLOCK:
        img = "unlocked"
    elif val == _IS_SUSPEND:
        img = "running"
    return img
            

def locked(last, icon):
    """Locking status."""
    val = _call(_LOCKED)
    val = _handle_val(val, last, _locked, icon)
    if val:
        last = val
    return last

def _handle_val(val, last, callback, icon):
    """Handle value switching."""
    if val is not None:
        if last != val:
            img = callback(val)
            icon.set_image(img)

def _brightness(val):
    use = "low"
    if val > 50:
        use = "mid"
    if val > 90:
        use = "high"
    return use + "-bright" 

def brightness(last, icon):
    """Get brightness."""
    val = _call(_BRIGHTNESS)
    val = _handle_val(val, last, _brightness, icon)
    if val:
        last = val
    return last
    

class Generic:
    def __init__(self, callback, image_path):
        """Init the instance."""
        self.statusicon = Gtk.StatusIcon()
        self._images = image_path
        self._callback = callback
        self._last = None
        self.set_image("unknown")
        self.on_timeout()

    def set_image(self, image):
        """Set icon image."""
        self.statusicon.set_from_file(os.path.join(self._images, image + ".png"))

    def on_timeout(self):
        """On timeout do a callback."""
        self._last = self._callback(self._last, self)
        # has to have timeout added
        GObject.timeout_add(3000, self.on_timeout)

def workspacing():
    """Handles workspace naming."""
    import datetime
    last_hash = None
    last_work = None
    debug = False
    count = 0
    success = True
    date = str(datetime.datetime.now()).replace(":", "-").replace(" ", "_").replace(".", "_")
    while True:
        try:
            forcing = _force_change(last_work, debug)
            last_work = forcing[0]
            force = forcing[1]
            if count == 0 or force:
                last_hash = on_change(last_hash, debug, force)
            success = True
        except Exception as e:
            with open(_HOME_TMP + date + ".tray.log", "a") as f:
                if success:
                    f.write("error")
                    f.write(str(e))
                    success = False
                else:
                    f.write("still broken")
                f.write("\n")
        count += 1
        time.sleep(0.25)
        if count == 4:
            count = 0

def main():
    """Entry point."""
    workspaces = threading.Thread(target=workspacing)
    workspaces.daemon = True
    workspaces.start()
    path = os.path.join(_HOME, ".config", "genericon")
    Generic(brightness, path)
    Generic(locked, path)
    Gtk.main()


def _is_active():
    for proc in ["weechat"]:
        pid = get_pid(proc)
        if pid < 0:
            continue
        if not os.path.exists(_HOME_TMP + proc + ".ready"):
            continue
        os.kill(pid, signal.SIGUSR2)

def get_pid(name):
    """Get pid."""
    try:
        pid = check_output(["pidof", name]).decode("utf-8").strip()
        val = int(pid)
        return val
    except:
        return -1

def uncurl(obj):
    """uncurl nest nodes down."""
    children = []
    for node in obj["nodes"]:
        for opened in uncurl(node):
            children.append(opened)
        children.append(node)
    return children


def _get_hash(cmd):
    """Run i3-msg command and get return/hash."""
    val = check_output(["i3-msg", "-t", cmd])
    m = hashlib.md5()
    m.update(val)
    cur = m.digest()
    return (val, cur)

def _force_change(hashed, debug):
    changed = []
    def _flagged(value):
        changed.append(1)
    hashed = _changing(hashed, debug, False, "get_workspaces", _flagged)
    return (hashed, len(changed) > 0)

def on_change(hashed, debug, force):
    """on interested changes, call this."""
    def _update(value):
        j = json.loads(value)
        workspaces = _get_workspaces(j)
        _rename_workspaces(workspaces)
        _is_active()
    return _changing(hashed, debug, force, "get_tree", _update)


def _changing(hashed, debug, force, command, callback):
    try:
        val = _get_hash(command)
        cur = val[1]
        tree = val[0]
        if cur == hashed:
            if not force:
                if debug:
                    print("no change")
                return cur
        callback(tree)
        return cur
    except Exception as e:
        if debug:
            print(e)
        return hashed


def _get_workspaces(j):
    """Get workspaces."""
    matched = {}
    for node in uncurl(j):
        if "num" in node and "name" in node:
            n = node["num"]
            name = node["name"]
            if n and n >= 1:
                children = []
                for c in uncurl(node):
                    if "window_properties" in c:
                        props = c["window_properties"]
                        if "class" in props:
                            classed = props["class"]
                            children.append(classed)
                matched[n] = (name, children)
    return matched

def _rename_workspaces(workspaces):
    """rename a workspace."""
    for k in workspaces:
        vals = workspaces[k]
        if len(vals[1]) == 0:
            named = str(k)
        else:
            named = ",".join([x[0:20].lower() for x in vals[1]])
            named = str(k) + ":" + named
        subprocess.call(["i3-msg",
                         "rename workspace \"{}\" to \"{}\"".format(vals[0], named)],
                         stdout=devnull,
                         stderr=subprocess.STDOUT)


if __name__ == "__main__":
    main()
