#!/usr/bin/python
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GObject
import subprocess
import os
import signal
import time
import json
import hashlib
from subprocess import check_output

devnull = open(os.devnull, 'w')

_HOME = "/home/enck/"
_IS_UNLOCK = 0
_IS_SUSPEND = 1
_BRIGHTNESS = 'xrandr --current --verbose | grep "Brightness" | cut -d ":" -f 2 | sed "s/0\.//g" | sed "s/1\.0/100/g" | tail -n 1 | awk \'{printf "%3.0f", $1}\' | sed "s/^[ \t]*//g"'
_LOCKED = """
#!/bin/bash
source """ + _HOME + """.bin/common
if [ -e $DISPLAY_UN ]; then
    echo """ + str(_IS_UNLOCK) + """
else
    if [ -e $DISPLAY_EN ]; then
        echo """ + str(_IS_SUSPEND) + """
    else
        echo 2
    fi
fi
"""

def _call(command):
    """Make a call, get change (else None)."""
    try:
        ret = subprocess.check_output(command, shell=True, executable='/bin/bash').decode("ascii").strip()
        return int(ret)
    except Exception as e:
        pass
    return None

def _locked(val):
    """Get locking image."""
    img = "display"
    if val == _IS_UNLOCK:
        img = "unlocked"
    elif val == _IS_SUSPEND:
        img = "running"
    return img
            

def locked(last, icon):
    """Locking status."""
    val = _call(_LOCKED)
    val = _handle_val(val, last, _locked, icon)
    if val:
        last = val
    return last

def _handle_val(val, last, callback, icon):
    """Handle value switching."""
    if val is not None:
        if last != val:
            img = callback(val)
            icon.set_image(img)

def _brightness(val):
    use = "low"
    if val > 50:
        use = "mid"
    if val > 90:
        use = "high"
    return use + "-bright" 

def brightness(last, icon):
    """Get brightness."""
    val = _call(_BRIGHTNESS)
    val = _handle_val(val, last, _brightness, icon)
    if val:
        last = val
    return last
    

class Generic:
    def __init__(self, callback, image_path):
        """Init the instance."""
        self.statusicon = Gtk.StatusIcon()
        self._images = image_path
        self._callback = callback
        self._last = None
        self.set_image("unknown")
        self.on_timeout()

    def set_image(self, image):
        """Set icon image."""
        self.statusicon.set_from_file(os.path.join(self._images, image + ".png"))

    def on_timeout(self):
        """On timeout do a callback."""
        self._last = self._callback(self._last, self)
        # has to have timeout added
        GObject.timeout_add(3000, self.on_timeout)


def main():
    """Entry point."""
    path = os.path.join(_HOME, ".config", "genericon")
    Generic(brightness, path)
    Generic(locked, path)
    last_hash = None
    while True:
        last_hash = on_change(last_hash, False)
        time.sleep(1)
    Gtk.main()

def _is_active():
    for proc in ["weechat"]:
        pid = get_pid(proc)
        if pid < 0:
            continue
        if not os.path.exists("/tmp/" + proc + ".ready"):
            continue
        os.kill(pid, signal.SIGUSR2)

def get_pid(name):
    """Get pid."""
    try:
        pid = check_output(["pidof", name]).decode("utf-8").strip()
        val = int(pid)
        return val
    except:
        return -1

def uncurl(obj):
    """uncurl nest nodes down."""
    children = []
    for node in obj["nodes"]:
        for opened in uncurl(node):
            children.append(opened)
        children.append(node)
    return children


def on_change(hashed, debug):
    """on interested changes, call this."""
    try:
        tree = check_output(["i3-msg", "-t", "get_tree"])
        m = hashlib.md5()
        m.update(tree)
        cur = m.digest()
        if cur == hashed:
            if debug:
                print("no change")
            return cur
        j = json.loads(tree)
        workspaces = _get_workspaces(j)
        _rename_workspaces(workspaces)
        _is_active()
        return cur
    except Exception as e:
        if debug:
            print(e)
        return hashed


def _get_workspaces(j):
    """Get workspaces."""
    matched = {}
    for node in uncurl(j):
        if "num" in node and "name" in node:
            n = node["num"]
            name = node["name"]
            if n and n >= 1:
                children = []
                for c in uncurl(node):
                    if "window_properties" in c:
                        props = c["window_properties"]
                        if "class" in props:
                            classed = props["class"]
                            children.append(classed)
                matched[n] = (name, children)
    return matched

def _rename_workspaces(workspaces):
    """rename a workspace."""
    for k in workspaces:
        vals = workspaces[k]
        if len(vals[1]) == 0:
            continue
        named = ",".join([x[0:20].lower() for x in vals[1]])
        named = str(k) + ":" + named
        subprocess.call(["i3-msg",
                         "rename workspace \"{}\" to \"{}\"".format(vals[0], named)],
                         stdout=devnull,
                         stderr=subprocess.STDOUT)


if __name__ == "__main__":
    main()
