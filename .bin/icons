#!/usr/bin/python
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GObject
import subprocess
import os
import signal
import datetime
import time
import json
from subprocess import check_output
import threading

devnull = open(os.devnull, 'w')

_HOME = "/home/enck/"
_HOME_TMP = _HOME + ".tmp/"
_IS_UNLOCK = 0
_IS_SUSPEND = 1
_BRIGHTNESS = 'xrandr --current --verbose | grep "Brightness" | cut -d ":" -f 2 | sed "s/0\.//g" | sed "s/1\.0/100/g" | tail -n 1 | awk \'{printf "%3.0f", $1}\' | sed "s/^[ \t]*//g"'
_LOCKED = """
#!/bin/bash
source """ + _HOME + """.bin/common
if [ -e $DISPLAY_UN ]; then
    echo """ + str(_IS_UNLOCK) + """
else
    if [ -e $DISPLAY_EN ]; then
        echo """ + str(_IS_SUSPEND) + """
    else
        echo 2
    fi
fi
"""
_VOLUME = "if [[ $(pamixer --get-mute) == 'true' ]]; then echo 1; else echo 0; fi"
_BAT = """
#!/bin/bash
charging=$(cat /sys/class/power_supply/AC/online)
NORMAL=5
LOW=20
low=0
normal=0
full=0
score=-1
for b in $(echo '0 1'); do
    _path='/sys/class/power_supply/BAT'$b'/capacity'
    if [ -e $_path ]; then
        if [ $score -lt 0 ]; then
            score=0
        fi
        _bat=$(cat $_path)
        if [ $_bat -le 30 ]; then
            score=$((score+$LOW))
        else
            if [ $_bat -le 80 ]; then
                score=$((score+$NORMAL))
            fi
        fi
    fi
done
flag='1'
if [ $score -lt $NORMAL ]; then
    if [ $score -ge 0 ]; then
        flag='3'
    fi
else
    if [ $score -lt $LOW ]; then
        flag='2'
    fi
fi
echo $flag$charging
"""

def _battery(val):
    img = "caution"
    if val == 21 or val == 11:
        img = "low-charging"
    elif val == 20:
        img = "good"
    elif val == 30:
        img = "full"
    elif val == 31:
        img = "good-charging"
    return "battery-{}".format(img)

def _call(command):
    """Make a call, get change (else None)."""
    try:
        ret = subprocess.check_output(command, shell=True, executable='/bin/bash').decode("ascii").strip()
        return int(ret)
    except Exception as e:
        pass
    return None

def _locked(val):
    """Get locking image."""
    img = "display"
    if val == _IS_UNLOCK:
        img = "unlocked"
    elif val == _IS_SUSPEND:
        img = "running"
    return img
            

def locked(last, icon):
    """Locking status."""
    val = _call(_LOCKED)
    val = _handle_val(val, last, _locked, icon)
    if val:
        last = val
    return last

def _handle_val(val, last, callback, icon):
    """Handle value switching."""
    if val is not None:
        if last != val:
            img = callback(val)
            icon.set_image(img)

def _volume(val):
    """Get volume icon."""
    if val == 1:
        return "muted"
    else:
        return "unmuted"

def volume(last, icon):
    """Handle volume."""
    val = _call(_VOLUME)
    val = _handle_val(val, last, _volume, icon)
    if val:
        last = val
    return val

def battery(last, icon):
    """Handle batteries."""
    val = _call(_BAT)
    val = _handle_val(val, last, _battery, icon)
    if val:
        last = val
    return val

def _brightness(val):
    use = "low"
    if val > 50:
        use = "mid"
    if val > 90:
        use = "high"
    return use + "-bright" 

def brightness(last, icon):
    """Get brightness."""
    val = _call(_BRIGHTNESS)
    val = _handle_val(val, last, _brightness, icon)
    if val:
        last = val
    return last
    

class Generic:
    def __init__(self, callback, image_path):
        """Init the instance."""
        self.statusicon = Gtk.StatusIcon()
        self._images = image_path
        self._callback = callback
        self._last = None
        self.set_image("unknown")
        self._called = None
        self.on_timeout()

    def reset(self):
        """Reset the icon."""
        self._called = None

    def set_image(self, image):
        """Set icon image."""
        self.statusicon.set_from_file(os.path.join(self._images, image + ".png"))

    def on_timeout(self, do_callback=True):
        """On timeout do a callback."""
        run = False
        next_call = datetime.datetime.now()
        if self._called is None:
            run = True
        else:
            delta_s = (next_call - self._called).total_seconds()
            run =  delta_s > 10
        if run:
            self._called = next_call
            self._last = self._callback(self._last, self)
        # has to have timeout added
        if do_callback:
            GObject.timeout_add(500, self.on_timeout)

def _get_socket():
    import socket
    import struct
    socket_path = subprocess.check_output(['i3', '--get-socketpath'], close_fds=True, universal_newlines=True).strip()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(socket_path)
    pay = '["window"]'.encode("utf-8")
    s = struct.pack('=II', len(pay), 2)
    sending = "i3-ipc".encode('utf-8') + s + pay
    sock.sendall(sending)
    return sock

def workspacing():
    """Handles workspace naming."""
    date = str(datetime.datetime.now()).replace(":", "-").replace(" ", "_").replace(".", "_")
    sock = None
    success = True
    while True:
        try:
            if sock is None:
                sock = _get_socket()
            data = sock.recv(1024).decode("utf-8", 'ignore')
            on_change()
            success = True
        except Exception as e:
            if sock:
                sock.close()
            with open(_HOME_TMP + date + ".tray.log", "a") as f:
                sock = None
                if success:
                    f.write("error")
                    f.write(str(e))
                    success = False
                else:
                    f.write("still broken")
                f.write("\n")
            time.sleep(5)

def main():
    """Entry point."""
    workspaces = threading.Thread(target=workspacing)
    workspaces.daemon = True
    workspaces.start()
    path = os.path.join(_HOME, ".config", "genericon")
    i = []
    i.append(Generic(battery, path))
    i.append(Generic(volume, path))
    i.append(Generic(brightness, path))
    i.append(Generic(locked, path))
    def sig_handler(signum, frame):
        for icon in i:
            icon.reset()
    signal.signal(signal.SIGUSR1, sig_handler)
    with open(_HOME_TMP + "icons.pid", 'w') as f:
        f.write(str(os.getpid()))
    Gtk.main()

def _is_active():
    for proc in ["weechat"]:
        pid = get_pid(proc)
        if pid < 0:
            continue
        if not os.path.exists(_HOME_TMP + proc + ".ready"):
            continue
        os.kill(pid, signal.SIGUSR2)

def get_pid(name):
    """Get pid."""
    try:
        pid = check_output(["pidof", name]).decode("utf-8").strip()
        val = int(pid)
        return val
    except:
        return -1

def uncurl(obj):
    """uncurl nest nodes down."""
    children = []
    for node in obj["nodes"]:
        for opened in uncurl(node):
            children.append(opened)
        children.append(node)
    return children


def on_change():
    """on interested changes, call this."""
    value = check_output(["i3-msg", "-t", "get_tree"])
    j = json.loads(value)
    workspaces = _get_workspaces(j)
    _rename_workspaces(workspaces)
    _is_active()


def _get_workspaces(j):
    """Get workspaces."""
    matched = {}
    for node in uncurl(j):
        if "num" in node and "name" in node:
            n = node["num"]
            name = node["name"]
            if n and n >= 1:
                children = []
                for c in uncurl(node):
                    if "window_properties" in c:
                        props = c["window_properties"]
                        if "class" in props:
                            classed = props["class"]
                            children.append(classed)
                matched[n] = (name, children)
    return matched

def _rename_workspaces(workspaces):
    """rename a workspace."""
    for k in workspaces:
        vals = workspaces[k]
        if len(vals[1]) == 0:
            named = str(k)
        else:
            named = ",".join([x[0:20].lower() for x in vals[1]])
            named = str(k) + ":" + named
        subprocess.call(["i3-msg",
                         "rename workspace \"{}\" to \"{}\"".format(vals[0], named)],
                         stdout=devnull,
                         stderr=subprocess.STDOUT)


if __name__ == "__main__":
    main()
